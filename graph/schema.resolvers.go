package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"dtm/db/db"
	"dtm/graph/model"
	"dtm/graph/utils"
	"dtm/mq/mq"
	"dtm/tx"
	"fmt"

	"github.com/google/uuid"
)

// CreateTrip is the resolver for the createTrip field.
func (r *mutationResolver) CreateTrip(ctx context.Context, input model.NewTrip) (*model.Trip, error) {
	dbTripInfo := r.TripDB
	id := uuid.New()
	tripInfo := &db.TripInfo{
		ID:   id,
		Name: input.Name,
	}
	if err := dbTripInfo.CreateTrip(tripInfo); err != nil {
		return nil, fmt.Errorf("failed to create trip: %w", err)
	}
	trip := &model.Trip{
		ID:   id.String(),
		Name: input.Name,
	}
	return trip, nil
}

// UpdateTrip is the resolver for the updateTrip field.
func (r *mutationResolver) UpdateTrip(ctx context.Context, id string, input model.NewTrip) (*model.Trip, error) {
	dbTripInfo := r.TripDB
	tripID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	tripInfo := &db.TripInfo{
		ID:   tripID,
		Name: input.Name,
	}
	if err := dbTripInfo.UpdateTripInfo(tripInfo); err != nil {
		return nil, fmt.Errorf("failed to update trip: %w", err)
	}

	trip := &model.Trip{
		ID:   id,
		Name: input.Name,
	}
	return trip, nil
}

// CreateRecord is the resolver for the createRecord field.
func (r *mutationResolver) CreateRecord(ctx context.Context, tripID string, input model.NewRecord) (*model.Record, error) {
	dbTripInfo := r.TripDB
	tripUUID, err := uuid.Parse(tripID)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	record := &db.Record{
		ID:               uuid.New(),
		Name:             input.Name,
		Amount:           input.Amount,
		PrePayAddress:    db.Address(input.PrePayAddress),
		ShouldPayAddress: make([]db.Address, len(input.ShouldPayAddress)),
	}
	for i, addr := range input.ShouldPayAddress {
		record.ShouldPayAddress[i] = db.Address(addr)
	}
	if err := dbTripInfo.CreateTripRecords(tripUUID, []db.Record{*record}); err != nil {
		return nil, fmt.Errorf("failed to create record: %w", err)
	}

	tripMQ := r.TripMessageQueueWrapper.GetTripRecordMessageQueue(mq.ActionCreate)
	if tripMQ.Publish(mq.TripRecordMessage{
		ID:            record.ID,
		Name:          record.Name,
		Amount:        record.Amount,
		PrePayAddress: record.PrePayAddress,
	}) != nil {
		fmt.Println("Warning: fail to notice event")
	}

	return &model.Record{
		ID:            record.ID.String(),
		Name:          record.Name,
		Amount:        record.Amount,
		PrePayAddress: string(record.PrePayAddress),
	}, nil
}

// UpdateRecord is the resolver for the updateRecord field.
func (r *mutationResolver) UpdateRecord(ctx context.Context, id string, input model.NewRecord) (*model.Record, error) {
	dbTripInfo := r.TripDB
	recordID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid record ID: %w", err)
	}

	record := &db.Record{
		ID:               recordID,
		Name:             input.Name,
		Amount:           input.Amount,
		PrePayAddress:    db.Address(input.PrePayAddress),
		ShouldPayAddress: make([]db.Address, len(input.ShouldPayAddress)),
	}
	for i, addr := range input.ShouldPayAddress {
		record.ShouldPayAddress[i] = db.Address(addr)
	}
	if err := dbTripInfo.UpdateTripRecord(*record); err != nil {
		return nil, fmt.Errorf("failed to update record: %w", err)
	}

	tripMQ := r.TripMessageQueueWrapper.GetTripRecordMessageQueue(mq.ActionUpdate)
	if tripMQ.Publish(mq.TripRecordMessage{
		ID:            record.ID,
		Name:          record.Name,
		Amount:        record.Amount,
		PrePayAddress: record.PrePayAddress,
	}) != nil {
		fmt.Println("Warning: fail to notice event")
	}

	return &model.Record{
		ID:            record.ID.String(),
		Name:          record.Name,
		Amount:        record.Amount,
		PrePayAddress: string(record.PrePayAddress),
	}, nil
}

// RemoveRecord is the resolver for the removeRecord field.
func (r *mutationResolver) RemoveRecord(ctx context.Context, id string) (string, error) {
	dbTripInfo := r.TripDB
	recordID, err := uuid.Parse(id)
	if err != nil {
		return "", fmt.Errorf("invalid record ID: %w", err)
	}

	if err := dbTripInfo.DeleteTripRecord(recordID); err != nil {
		return "", fmt.Errorf("failed to delete record: %w", err)
	}

	tripMQ := r.TripMessageQueueWrapper.GetTripRecordMessageQueue(mq.ActionCreate)
	if tripMQ.Publish(mq.TripRecordMessage{
		ID: recordID,
	}) != nil {
		fmt.Println("Warning: fail to notice event")
	}

	return id, nil
}

// CreateAddress is the resolver for the createAddress field.
func (r *mutationResolver) CreateAddress(ctx context.Context, tripID string, address string) (string, error) {
	dbTripInfo := r.TripDB
	tripUUID, err := uuid.Parse(tripID)
	if err != nil {
		return "", fmt.Errorf("invalid trip ID: %w", err)
	}

	if err := dbTripInfo.TripAddressListAdd(tripUUID, db.Address(address)); err != nil {
		return "", fmt.Errorf("failed to create address: %w", err)
	}

	tripMQ := r.TripMessageQueueWrapper.GetTripAddressMessageQueue(mq.ActionCreate)
	if tripMQ.Publish(mq.TripAddressMessage{
		Address: db.Address(address),
	}) != nil {
		fmt.Println("Warning: fail to notice event")
		return address, nil
	}

	return address, nil
}

// DeleteAddress is the resolver for the deleteAddress field.
func (r *mutationResolver) DeleteAddress(ctx context.Context, tripID string, address string) (string, error) {
	dbTripInfo := r.TripDB
	tripUUID, err := uuid.Parse(tripID)
	if err != nil {
		return "", fmt.Errorf("invalid trip ID: %w", err)
	}

	if err := dbTripInfo.TripAddressListRemove(tripUUID, db.Address(address)); err != nil {
		return "", fmt.Errorf("failed to delete address: %w", err)
	}

	tripMQ := r.TripMessageQueueWrapper.GetTripAddressMessageQueue(mq.ActionDelete)
	if tripMQ.Publish(mq.TripAddressMessage{
		Address: db.Address(address),
	}) != nil {
		fmt.Println("Warning: fail to notice event")
		return address, nil
	}

	return address, nil
}

// Trip is the resolver for the trip field.
func (r *queryResolver) Trip(ctx context.Context, id string) (*model.Trip, error) {
	dbTripInfo := r.TripDB
	tripID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	tripInfo, err := dbTripInfo.GetTripInfo(tripID)
	if err != nil {
		return nil, fmt.Errorf("failed to get trip info: %w", err)
	}

	return &model.Trip{
		ID:   tripInfo.ID.String(),
		Name: tripInfo.Name,
	}, nil
}

// ShouldPayAddress is the resolver for the shouldPayAddress field.
func (r *recordResolver) ShouldPayAddress(ctx context.Context, obj *model.Record) ([]string, error) {
	dbTripInfo := r.TripDB
	recordID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid record ID: %w", err)
	}

	addresses, err := dbTripInfo.GetRecordAddressList(recordID)
	if err != nil {
		return nil, fmt.Errorf("failed to get record: %w", err)
	}
	addressList := make([]string, len(addresses))
	for i, addr := range addresses {
		addressList[i] = string(addr)
	}
	return addressList, nil
}

// SubRecordCreate is the resolver for the subRecordCreate field.
func (r *subscriptionResolver) SubRecordCreate(ctx context.Context, tripID string) (<-chan *model.Record, error) {
	tripMQ := r.TripMessageQueueWrapper.GetTripRecordMessageQueue(mq.ActionCreate)
	if tripMQ == nil {
		return nil, fmt.Errorf("can not get target message MQ")
	}

	recordStream := make(chan *model.Record)

	mq.SubscribeProcessor(
		ctx,
		tripMQ,
		utils.TripRecordMQ2GQL,
		recordStream,
	)
	return recordStream, nil
}

// SubRecordDelete is the resolver for the subRecordDelete field.
func (r *subscriptionResolver) SubRecordDelete(ctx context.Context, tripID string) (<-chan *model.Record, error) {
	tripMQ := r.TripMessageQueueWrapper.GetTripRecordMessageQueue(mq.ActionDelete)
	if tripMQ == nil {
		return nil, fmt.Errorf("can not get target message MQ")
	}

	recordStream := make(chan *model.Record)

	mq.SubscribeProcessor(
		ctx,
		tripMQ,
		utils.TripRecordMQ2GQL,
		recordStream,
	)
	return recordStream, nil
}

// SubRecordUpdate is the resolver for the subRecordUpdate field.
func (r *subscriptionResolver) SubRecordUpdate(ctx context.Context, tripID string) (<-chan *model.Record, error) {
	tripMQ := r.TripMessageQueueWrapper.GetTripRecordMessageQueue(mq.ActionUpdate)
	if tripMQ == nil {
		return nil, fmt.Errorf("can not get target message MQ")
	}

	recordStream := make(chan *model.Record)

	mq.SubscribeProcessor(
		ctx,
		tripMQ,
		utils.TripRecordMQ2GQL,
		recordStream,
	)
	return recordStream, nil
}

// SubAddressCreate is the resolver for the subAddressCreate field.
func (r *subscriptionResolver) SubAddressCreate(ctx context.Context, tripID string) (<-chan string, error) {
	tripMQ := r.TripMessageQueueWrapper.GetTripAddressMessageQueue(mq.ActionCreate)
	if tripMQ == nil {
		return nil, fmt.Errorf("can not get target message MQ")
	}

	recordStream := make(chan string)

	mq.SubscribeProcessor(
		ctx,
		tripMQ,
		utils.TripAddressMQ2GQL,
		recordStream,
	)
	return recordStream, nil
}

// SubAddressDelete is the resolver for the subAddressDelete field.
func (r *subscriptionResolver) SubAddressDelete(ctx context.Context, tripID string) (<-chan string, error) {
	tripMQ := r.TripMessageQueueWrapper.GetTripAddressMessageQueue(mq.ActionDelete)
	if tripMQ == nil {
		return nil, fmt.Errorf("can not get target message MQ")
	}

	recordStream := make(chan string)

	mq.SubscribeProcessor(
		ctx,
		tripMQ,
		utils.TripAddressMQ2GQL,
		recordStream,
	)
	return recordStream, nil
}

// Records is the resolver for the records field.
func (r *tripResolver) Records(ctx context.Context, obj *model.Trip) ([]*model.Record, error) {
	dbTripInfo := r.TripDB
	tripID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	records, err := dbTripInfo.GetTripRecords(tripID)
	if err != nil {
		return nil, fmt.Errorf("failed to get trip records: %w", err)
	}

	recordModels := make([]*model.Record, len(records))
	for i, record := range records {
		recordModels[i] = &model.Record{
			ID:            record.ID.String(),
			Name:          record.Name,
			Amount:        record.Amount,
			PrePayAddress: string(record.PrePayAddress),
		}
	}
	return recordModels, nil
}

// MoneyShare is the resolver for the moneyShare field.
func (r *tripResolver) MoneyShare(ctx context.Context, obj *model.Trip) ([]*model.Tx, error) {
	dbTripInfo := r.TripDB
	tripID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	records, err := dbTripInfo.GetTripRecords(tripID)
	if err != nil {
		return nil, fmt.Errorf("failed to get trip records: %w", err)
	}

	// Process records to create money share transactions
	payments := make([]tx.UserPayment, 0, len(records))
	for _, record := range records {
		if record.Amount <= 0 {
			continue // Skip records with non-positive amounts
		}
		payment := tx.UserPayment{
			Name:             record.Name,
			Amount:           record.Amount,
			PrePayAddress:    string(record.PrePayAddress),
			ShouldPayAddress: make([]string, len(record.ShouldPayAddress)),
		}
		for i, addr := range record.ShouldPayAddress {
			payment.ShouldPayAddress[i] = string(addr)
		}
		payments = append(payments, payment)
	}
	txPackage, totalRemaining, err := tx.ShareMoneyEasyNoLog(payments)
	if err != nil {
		return nil, fmt.Errorf("failed to create TxPackage: %w", err)
	}
	if totalRemaining > 0.1 {
		return nil, fmt.Errorf("there are remaining unspent inputs totaling %.2f, please check your records", totalRemaining)
	}

	txList := make([]*model.Tx, len(txPackage.TxList))
	for i, tx := range txPackage.TxList {
		txList[i] = &model.Tx{
			Input: make([]*model.Payment, len(tx.Input)),
			Output: &model.Payment{
				Address: tx.Output.Address,
				Amount:  tx.Output.Amount,
			},
		}
		for j, input := range tx.Input {
			txList[i].Input[j] = &model.Payment{
				Address: input.Address,
				Amount:  input.Amount,
			}
		}
	}

	return txList, nil
}

// AddressList is the resolver for the addressList field.
func (r *tripResolver) AddressList(ctx context.Context, obj *model.Trip) ([]string, error) {
	dbTripInfo := r.TripDB
	tripID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	addresses, err := dbTripInfo.GetTripAddressList(tripID)
	if err != nil {
		return nil, fmt.Errorf("failed to get trip addresses: %w", err)
	}

	addressList := make([]string, len(addresses))
	for i, addr := range addresses {
		addressList[i] = string(addr)
	}
	return addressList, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Record returns RecordResolver implementation.
func (r *Resolver) Record() RecordResolver { return &recordResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

// Trip returns TripResolver implementation.
func (r *Resolver) Trip() TripResolver { return &tripResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type recordResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type tripResolver struct{ *Resolver }
