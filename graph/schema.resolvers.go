package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"dtm/db/db"
	"dtm/graph/model"
	"dtm/graph/utils"
	"dtm/mq/mq"
	"dtm/tx"
	"fmt"
	"strconv"

	"github.com/google/uuid"
)

// CreateTrip is the resolver for the createTrip field.
func (r *mutationResolver) CreateTrip(ctx context.Context, input model.NewTrip) (*model.Trip, error) {
	if !utils.VerifyStringRequest(input.Name) {
		return nil, fmt.Errorf("invalid trip name")
	}

	dbTripInfo := r.TripDB
	id := uuid.New()
	tripInfo := &db.TripInfo{
		ID:   id,
		Name: input.Name,
	}
	if err := dbTripInfo.CreateTrip(tripInfo); err != nil {
		return nil, fmt.Errorf("failed to create trip: %w", err)
	}
	trip := &model.Trip{
		ID:   id.String(),
		Name: input.Name,
	}
	return trip, nil
}

// UpdateTrip is the resolver for the updateTrip field.
func (r *mutationResolver) UpdateTrip(ctx context.Context, tripID string, input model.NewTrip) (*model.Trip, error) {
	if !utils.VerifyStringRequest(input.Name) {
		return nil, fmt.Errorf("invalid trip name")
	}

	dbTripInfo := r.TripDB
	id, err := uuid.Parse(tripID)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	tripInfo := &db.TripInfo{
		ID:   id,
		Name: input.Name,
	}
	if err := dbTripInfo.UpdateTripInfo(tripInfo); err != nil {
		return nil, fmt.Errorf("failed to update trip: %w", err)
	}

	trip := &model.Trip{
		ID:   tripID,
		Name: input.Name,
	}
	return trip, nil
}

// CreateRecord is the resolver for the createRecord field.
func (r *mutationResolver) CreateRecord(ctx context.Context, tripID string, input model.NewRecord) (*model.Record, error) {
	if !utils.VerifyRecordRequestAndSetDefault(&input) {
		return nil, fmt.Errorf("invalid record input")
	}

	dbTripInfo := r.TripDB
	tripUUID, err := uuid.Parse(tripID)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	record, err := utils.MapNewRecordToDBRecord(input)
	if err != nil {
		return nil, err
	}
	record.ID = uuid.New() // Set new ID for creation

	if err := dbTripInfo.CreateTripRecords(tripUUID, []db.Record{*record}); err != nil {
		return nil, fmt.Errorf("failed to create record: %w", err)
	}

	tripMQ := r.TripMessageQueueWrapper.GetTripRecordMessageQueue(mq.ActionCreate)
	if err := tripMQ.Publish(mq.TripRecordMessage{
		TripID:        tripUUID,
		ID:            record.ID,
		Name:          record.Name,
		Amount:        record.Amount,
		Time:          strconv.FormatInt(record.Time.UnixMilli(), 10),
		PrePayAddress: record.PrePayAddress,
		Category:      utils.RecordCategory2Int(input.Category),
	}); err != nil {
		fmt.Println("Warning: fail to notice event: " + err.Error())
	}

	return &model.Record{
		ID:            record.ID.String(),
		Name:          record.Name,
		Amount:        record.Amount,
		Time:          strconv.FormatInt(record.Time.UnixMilli(), 10),
		PrePayAddress: string(record.PrePayAddress),
		Category:      *input.Category,
	}, nil
}

// UpdateRecord is the resolver for the updateRecord field.
func (r *mutationResolver) UpdateRecord(ctx context.Context, recordID string, input model.NewRecord) (*model.Record, error) {
	if !utils.VerifyRecordRequestAndSetDefault(&input) {
		return nil, fmt.Errorf("invalid record input")
	}

	dbTripInfo := r.TripDB
	record, err := utils.MapNewRecordToDBRecord(input)
	if err != nil {
		return nil, err
	}
	record.ID, err = uuid.Parse(recordID)
	if err != nil {
		return nil, fmt.Errorf("invalid record ID: %w", err)
	}

	var tripId uuid.UUID
	if tripId, err = dbTripInfo.UpdateTripRecord(record); err != nil {
		return nil, fmt.Errorf("failed to update record: %w", err)
	}

	tripMQ := r.TripMessageQueueWrapper.GetTripRecordMessageQueue(mq.ActionUpdate)
	if err := tripMQ.Publish(mq.TripRecordMessage{
		TripID:        tripId,
		ID:            record.ID,
		Name:          record.Name,
		Amount:        record.Amount,
		Time:          strconv.FormatInt(record.Time.UnixMilli(), 10),
		PrePayAddress: record.PrePayAddress,
		Category:      utils.RecordCategory2Int(input.Category),
	}); err != nil {
		fmt.Println("Warning: fail to notice event: " + err.Error())
	}

	return &model.Record{
		ID:            record.ID.String(),
		Name:          record.Name,
		Amount:        record.Amount,
		Time:          strconv.FormatInt(record.Time.UnixMilli(), 10),
		PrePayAddress: string(record.PrePayAddress),
		Category:      *input.Category,
	}, nil
}

// RemoveRecord is the resolver for the removeRecord field.
func (r *mutationResolver) RemoveRecord(ctx context.Context, recordID string) (string, error) {
	dbTripInfo := r.TripDB
	recordUID, err := uuid.Parse(recordID)
	if err != nil {
		return "", fmt.Errorf("invalid record ID: %w", err)
	}
	var tripId uuid.UUID
	if tripId, err = dbTripInfo.DeleteTripRecord(recordUID); err != nil {
		return "", fmt.Errorf("failed to delete record: %w", err)
	}

	tripMQ := r.TripMessageQueueWrapper.GetTripRecordMessageQueue(mq.ActionDelete)
	if err := tripMQ.Publish(mq.TripRecordMessage{
		TripID: tripId,
		ID:     recordUID,
	}); err != nil {
		fmt.Println("Warning: fail to notice event: " + err.Error())
	}

	return recordID, nil
}

// CreateAddress is the resolver for the createAddress field.
func (r *mutationResolver) CreateAddress(ctx context.Context, tripID string, address string) (string, error) {
	if !utils.VerifyStringRequest(address) {
		return "", fmt.Errorf("invalid address")
	}

	dbTripInfo := r.TripDB
	tripUUID, err := uuid.Parse(tripID)
	if err != nil {
		return "", fmt.Errorf("invalid trip ID: %w", err)
	}

	if err := dbTripInfo.TripAddressListAdd(tripUUID, db.Address(address)); err != nil {
		return "", fmt.Errorf("failed to create address: %w", err)
	}

	tripMQ := r.TripMessageQueueWrapper.GetTripAddressMessageQueue(mq.ActionCreate)
	if err := tripMQ.Publish(mq.TripAddressMessage{
		TripID:  tripUUID,
		Address: db.Address(address),
	}); err != nil {
		fmt.Println("Warning: fail to notice event: " + err.Error())
		return address, nil
	}

	return address, nil
}

// DeleteAddress is the resolver for the deleteAddress field.
func (r *mutationResolver) DeleteAddress(ctx context.Context, tripID string, address string) (string, error) {
	dbTripInfo := r.TripDB
	tripUUID, err := uuid.Parse(tripID)
	if err != nil {
		return "", fmt.Errorf("invalid trip ID: %w", err)
	}

	if err := dbTripInfo.TripAddressListRemove(tripUUID, db.Address(address)); err != nil {
		return "", fmt.Errorf("failed to delete address: %w", err)
	}

	tripMQ := r.TripMessageQueueWrapper.GetTripAddressMessageQueue(mq.ActionDelete)
	if err := tripMQ.Publish(mq.TripAddressMessage{
		TripID:  tripUUID,
		Address: db.Address(address),
	}); err != nil {
		fmt.Println("Warning: fail to notice event: " + err.Error())
		return address, nil
	}

	return address, nil
}

// Trip is the resolver for the trip field.
func (r *queryResolver) Trip(ctx context.Context, tripID string) (*model.Trip, error) {
	ginCtx, err := utils.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}
	dataLoader, ok := ginCtx.Value(string(db.DataLoaderKeyTripData)).(*db.TripDataLoader)
	if !ok {
		return nil, fmt.Errorf("data loader is not available")
	}

	id, err := uuid.Parse(tripID)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	tripInfo, err := dataLoader.GetTripInfoList.Load(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get trip info: %w", err)
	}
	if tripInfo == nil {
		return nil, fmt.Errorf("trip not found with ID: %s", tripID)
	}

	return &model.Trip{
		ID:   tripInfo.ID.String(),
		Name: tripInfo.Name,
	}, nil
}

// ShouldPayAddress is the resolver for the shouldPayAddress field.
func (r *recordResolver) ShouldPayAddress(ctx context.Context, obj *model.Record) ([]string, error) {
	addresses, err := utils.GetShouldPayList(ctx, obj)
	if err != nil {
		return nil, fmt.Errorf("failed to get should pay addresses: %w", err)
	}

	addressList := make([]string, len(addresses))
	for i, addr := range addresses {
		addressList[i] = string(addr.Address)
	}
	return addressList, nil
}

// ExtendPayMsg is the resolver for the extendPayMsg field.
func (r *recordResolver) ExtendPayMsg(ctx context.Context, obj *model.Record) ([]float64, error) {
	addresses, err := utils.GetShouldPayList(ctx, obj)
	if err != nil {
		return nil, fmt.Errorf("failed to get should pay addresses: %w", err)
	}

	msgList := make([]float64, len(addresses))
	for i, addr := range addresses {
		msgList[i] = float64(addr.ExtendMsg)
	}
	return msgList, nil
}

// IsValid is the resolver for the isValid field.
func (r *recordResolver) IsValid(ctx context.Context, obj *model.Record) (bool, error) {
	addresses, err := utils.GetShouldPayList(ctx, obj)
	if err != nil {
		return false, fmt.Errorf("failed to get should pay addresses: %w", err)
	}

	payment := tx.UserPayment{
		Name:             obj.Name,
		PrePayAddress:    obj.PrePayAddress,
		Amount:           obj.Amount,
		ShouldPayAddress: make([]string, len(addresses)),
		ExtendPayMsg:     make([]float64, len(addresses)),
		Strategy:         tx.ShareMoneyStrategyFactory(utils.RecordCategory2Int(&obj.Category)),
	}

	for i, addr := range addresses {
		payment.ShouldPayAddress[i] = string(addr.Address)
		payment.ExtendPayMsg[i] = addr.ExtendMsg
	}
	if t, err := payment.ToTx(payment.Strategy); err != nil {
		// fmt.Printf("failed to convert UserPayment to Tx: %w", err)
		return false, nil
	} else if t.BoolValidate() {
		return true, nil
	}
	return false, nil
}

// SubRecordCreate is the resolver for the subRecordCreate field.
func (r *subscriptionResolver) SubRecordCreate(ctx context.Context, tripID string) (<-chan *model.Record, error) {
	tripMQ := r.TripMessageQueueWrapper.GetTripRecordMessageQueue(mq.ActionCreate)
	if tripMQ == nil {
		return nil, fmt.Errorf("can not get target message MQ")
	}
	tripUUID, err := uuid.Parse(tripID)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	recordStream := make(chan *model.Record)

	mq.SubscribeProcessor(
		tripUUID,
		ctx,
		tripMQ,
		utils.TripRecordMQ2GQL,
		recordStream,
	)
	return recordStream, nil
}

// SubRecordDelete is the resolver for the subRecordDelete field.
func (r *subscriptionResolver) SubRecordDelete(ctx context.Context, tripID string) (<-chan string, error) {
	tripMQ := r.TripMessageQueueWrapper.GetTripRecordMessageQueue(mq.ActionDelete)
	if tripMQ == nil {
		return nil, fmt.Errorf("can not get target message MQ")
	}
	tripUUID, err := uuid.Parse(tripID)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	recordStream := make(chan string)

	mq.SubscribeProcessor(
		tripUUID,
		ctx,
		tripMQ,
		utils.TripRecordIdMQ2GQL,
		recordStream,
	)
	return recordStream, nil
}

// SubRecordUpdate is the resolver for the subRecordUpdate field.
func (r *subscriptionResolver) SubRecordUpdate(ctx context.Context, tripID string) (<-chan *model.Record, error) {
	tripMQ := r.TripMessageQueueWrapper.GetTripRecordMessageQueue(mq.ActionUpdate)
	if tripMQ == nil {
		return nil, fmt.Errorf("can not get target message MQ")
	}
	tripUUID, err := uuid.Parse(tripID)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	recordStream := make(chan *model.Record)

	mq.SubscribeProcessor(
		tripUUID,
		ctx,
		tripMQ,
		utils.TripRecordMQ2GQL,
		recordStream,
	)
	return recordStream, nil
}

// SubAddressCreate is the resolver for the subAddressCreate field.
func (r *subscriptionResolver) SubAddressCreate(ctx context.Context, tripID string) (<-chan string, error) {
	tripMQ := r.TripMessageQueueWrapper.GetTripAddressMessageQueue(mq.ActionCreate)
	if tripMQ == nil {
		return nil, fmt.Errorf("can not get target message MQ")
	}
	tripUUID, err := uuid.Parse(tripID)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	recordStream := make(chan string)

	mq.SubscribeProcessor(
		tripUUID,
		ctx,
		tripMQ,
		utils.TripAddressMQ2GQL,
		recordStream,
	)
	return recordStream, nil
}

// SubAddressDelete is the resolver for the subAddressDelete field.
func (r *subscriptionResolver) SubAddressDelete(ctx context.Context, tripID string) (<-chan string, error) {
	tripMQ := r.TripMessageQueueWrapper.GetTripAddressMessageQueue(mq.ActionDelete)
	if tripMQ == nil {
		return nil, fmt.Errorf("can not get target message MQ")
	}
	tripUUID, err := uuid.Parse(tripID)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	recordStream := make(chan string)
	mq.SubscribeProcessor(
		tripUUID,
		ctx,
		tripMQ,
		utils.TripAddressMQ2GQL,
		recordStream,
	)
	return recordStream, nil
}

// Records is the resolver for the records field.
func (r *tripResolver) Records(ctx context.Context, obj *model.Trip) ([]*model.Record, error) {
	ginCtx, err := utils.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}
	dataLoader, ok := ginCtx.Value(string(db.DataLoaderKeyTripData)).(*db.TripDataLoader)
	if !ok {
		return nil, fmt.Errorf("data loader is not available")
	}

	tripID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	records, err := dataLoader.GetRecordInfoList.Load(ctx, tripID)
	if err != nil {
		return nil, fmt.Errorf("failed to get trip records: %w", err)
	}

	recordModels := make([]*model.Record, len(records))
	for i, record := range records {
		recordModels[i] = &model.Record{
			ID:            record.ID.String(),
			Name:          record.Name,
			Amount:        record.Amount,
			Time:          strconv.FormatInt(record.Time.UnixMilli(), 10),
			PrePayAddress: string(record.PrePayAddress),
			Category:      utils.Int2RecordCategory(int(record.Category)),
		}
	}
	return recordModels, nil
}

// MoneyShare is the resolver for the moneyShare field.
func (r *tripResolver) MoneyShare(ctx context.Context, obj *model.Trip) ([]*model.Tx, error) {
	txPackage, totalRemaining, isValid, err := utils.CalculateMoneyShare(ctx, obj)
	if err != nil {
		return nil, fmt.Errorf("failed to create TxPackage: %w", err)
	}
	if totalRemaining > 0.1 {
		return nil, fmt.Errorf("there are remaining unspent inputs totaling %.2f, please check your records", totalRemaining)
	}

	if !isValid {
		return []*model.Tx{}, nil
	}

	return utils.ToModelTxList(txPackage.TxList), nil
}

// AddressList is the resolver for the addressList field.
func (r *tripResolver) AddressList(ctx context.Context, obj *model.Trip) ([]string, error) {
	ginCtx, err := utils.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}
	dataLoader, ok := ginCtx.Value(string(db.DataLoaderKeyTripData)).(*db.TripDataLoader)
	if !ok {
		return nil, fmt.Errorf("data loader is not available")
	}

	tripID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid trip ID: %w", err)
	}

	addresses, err := dataLoader.GetTripAddressList.Load(ctx, tripID)
	if err != nil {
		return nil, fmt.Errorf("failed to get trip addresses: %w", err)
	}

	addressList := make([]string, len(addresses))
	for i, addr := range addresses {
		addressList[i] = string(addr)
	}
	return addressList, nil
}

// IsValid is the resolver for the isValid field.
func (r *tripResolver) IsValid(ctx context.Context, obj *model.Trip) (bool, error) {
	_, totalRemaining, isValid, err := utils.CalculateMoneyShare(ctx, obj)
	if err != nil {
		return false, fmt.Errorf("failed to create TxPackage: %w", err)
	}
	if totalRemaining > 0.1 {
		return false, fmt.Errorf("there are remaining unspent inputs totaling %.2f, please check your records", totalRemaining)
	}

	return isValid, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Record returns RecordResolver implementation.
func (r *Resolver) Record() RecordResolver { return &recordResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

// Trip returns TripResolver implementation.
func (r *Resolver) Trip() TripResolver { return &tripResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type recordResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type tripResolver struct{ *Resolver }
